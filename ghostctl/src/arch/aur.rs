use dialoguer::{theme::ColorfulTheme, Confirm, Input, MultiSelect, Select};
use std::process::Command;

pub fn aur_helper_management() {
    println!("üì¶ AUR Helper Management");
    println!("========================");

    let options = [
        "üîç Check installed AUR helpers",
        "‚≠ê Set preferred AUR helper",
        "üì• Install AUR helper",
        "üîÑ Update AUR packages",
        "üßπ Clean AUR cache",
        "üîß Advanced Package Management",
        "ü©∫ Diagnose & Fix Broken Packages",
        "üîó Dependency Resolution Tools",
        "üìã Package Conflict Resolution",
        "‚¨ÖÔ∏è  Back",
    ];

    let choice = Select::with_theme(&ColorfulTheme::default())
        .with_prompt("AUR Helper Management")
        .items(&options)
        .default(0)
        .interact()
        .unwrap();

    match choice {
        0 => check_aur_helpers(),
        1 => set_preferred_aur_helper(),
        2 => install_aur_helper(),
        3 => update_aur_packages(),
        4 => clean_aur_cache(),
        5 => advanced_package_management(),
        6 => diagnose_broken_packages(),
        7 => dependency_resolution_tools(),
        8 => package_conflict_resolution(),
        _ => return,
    }
}

fn check_aur_helpers() {
    println!("üîç Checking AUR Helpers");
    println!("=======================");

    let helpers = [
        ("reaper", "reap", "GhostKellz's modern AUR helper"),
        ("paru", "paru", "Feature packed AUR helper"),
        ("yay", "yay", "Yet another Yogurt AUR helper"),
        ("trizen", "trizen", "Lightweight AUR helper"),
        ("pikaur", "pikaur", "AUR helper with minimal dependencies"),
    ];

    let mut found_helpers = Vec::new();

    for (name, cmd, description) in &helpers {
        if Command::new("which").arg(cmd).status().is_ok() {
            println!("  ‚úÖ {} - {}", name, description);
            found_helpers.push(*name);
        } else {
            println!("  ‚ùå {} - {} (not installed)", name, description);
        }
    }

    if found_helpers.is_empty() {
        println!("\nüí° No AUR helpers found. Consider installing one!");
    } else {
        println!("\nüìä Found {} AUR helper(s)", found_helpers.len());
    }
}

fn install_aur_helper() {
    println!("üì• Install AUR Helper");
    println!("====================");

    let helpers = [
        "reaper (Recommended - GhostKellz)",
        "paru (Feature rich)",
        "yay (Popular choice)",
    ];

    let choice = Select::with_theme(&ColorfulTheme::default())
        .with_prompt("Select AUR helper to install")
        .items(&helpers)
        .default(0)
        .interact()
        .unwrap();

    match choice {
        0 => install_reaper(),
        1 => install_paru(),
        2 => install_yay(),
        _ => return,
    }
}

fn install_reaper() {
    println!("üî• Installing Reaper AUR Helper");
    println!("===============================");

    let confirm = Confirm::new()
        .with_prompt("Install Reaper via official installer?")
        .default(true)
        .interact()
        .unwrap();

    if confirm {
        println!("üì• Downloading and installing Reaper...");
        let status = Command::new("bash")
            .arg("-c")
            .arg("curl -sSL https://raw.githubusercontent.com/face-hh/reaper/main/release/install.sh | bash")
            .status();

        match status {
            Ok(s) if s.success() => {
                println!("‚úÖ Reaper installed successfully!");
                println!("üí° Use 'reap -S package' to install AUR packages");
            }
            _ => println!("‚ùå Failed to install Reaper"),
        }
    }
}

fn install_paru() {
    println!("ü¶Ä Installing Paru AUR Helper");
    println!("=============================");

    // Check if rust is installed
    if Command::new("which").arg("cargo").status().is_err() {
        println!("üì¶ Installing Rust toolchain...");
        let _ = Command::new("sudo")
            .args(["pacman", "-S", "--noconfirm", "rust"])
            .status();
    }

    let confirm = Confirm::new()
        .with_prompt("Build and install Paru from AUR?")
        .default(true)
        .interact()
        .unwrap();

    if confirm {
        println!("üî® Building Paru from source...");
        let build_dir = "/tmp/paru-build";

        let _ = std::fs::remove_dir_all(build_dir);

        let status = Command::new("git")
            .args(["clone", "https://aur.archlinux.org/paru.git", build_dir])
            .status();

        if status.is_ok() && status.unwrap().success() {
            let build_status = Command::new("makepkg")
                .args(["-si", "--noconfirm"])
                .current_dir(build_dir)
                .status();

            match build_status {
                Ok(s) if s.success() => {
                    println!("‚úÖ Paru installed successfully!");
                    println!("üí° Use 'paru -S package' to install AUR packages");
                }
                _ => println!("‚ùå Failed to build Paru"),
            }
        }

        let _ = std::fs::remove_dir_all(build_dir);
    }
}

fn install_yay() {
    println!("üöÄ Installing Yay AUR Helper");
    println!("============================");

    let confirm = Confirm::new()
        .with_prompt("Build and install Yay from AUR?")
        .default(true)
        .interact()
        .unwrap();

    if confirm {
        println!("üî® Building Yay from source...");
        let build_dir = "/tmp/yay-build";

        let _ = std::fs::remove_dir_all(build_dir);

        let status = Command::new("git")
            .args(["clone", "https://aur.archlinux.org/yay.git", build_dir])
            .status();

        if status.is_ok() && status.unwrap().success() {
            let build_status = Command::new("makepkg")
                .args(["-si", "--noconfirm"])
                .current_dir(build_dir)
                .status();

            match build_status {
                Ok(s) if s.success() => {
                    println!("‚úÖ Yay installed successfully!");
                    println!("üí° Use 'yay -S package' to install AUR packages");
                }
                _ => println!("‚ùå Failed to build Yay"),
            }
        }

        let _ = std::fs::remove_dir_all(build_dir);
    }
}

fn update_aur_packages() {
    println!("üîÑ Update AUR Packages");
    println!("======================");

    // Try available AUR helpers
    let helpers = [("reap", "-Syu"), ("paru", "-Syu"), ("yay", "-Syu")];

    for (helper, args) in &helpers {
        if Command::new("which").arg(helper).status().is_ok() {
            println!("üîÑ Updating with {}...", helper);
            let _ = Command::new(helper).arg(args).status();
            return;
        }
    }

    println!("‚ùå No AUR helper found for updates");
}

fn clean_aur_cache() {
    println!("üßπ Clean AUR Cache");
    println!("==================");

    // Try available AUR helpers
    let helpers = [("reap", "-Sc"), ("paru", "-Sc"), ("yay", "-Sc")];

    for (helper, args) in &helpers {
        if Command::new("which").arg(helper).status().is_ok() {
            let confirm = Confirm::new()
                .with_prompt(format!("Clean cache with {}?", helper))
                .default(true)
                .interact()
                .unwrap();

            if confirm {
                let _ = Command::new(helper).arg(args).status();
            }
            return;
        }
    }

    println!("‚ùå No AUR helper found for cache cleaning");
}

fn set_preferred_aur_helper() {
    println!("‚≠ê Set Preferred AUR Helper");
    println!("===========================");

    // Check which helpers are installed
    let helpers = [
        (
            "reaper (reap command)",
            "reap",
            "GhostKellz's modern AUR helper",
        ),
        ("paru", "paru", "Feature packed AUR helper"),
        ("yay", "yay", "Yet another Yogurt AUR helper"),
    ];

    let mut available_helpers = Vec::new();
    let mut helper_options = Vec::new();

    for (display_name, cmd, description) in &helpers {
        if Command::new("which").arg(cmd).status().is_ok() {
            available_helpers.push(*cmd);
            helper_options.push(format!("{} - {}", display_name, description));
        }
    }

    if available_helpers.is_empty() {
        println!("‚ùå No preferred AUR helpers found installed.");
        println!("Please install one of: reap, paru, or yay first.");
        return;
    }

    // Show current preferred helper
    if let Some(current) = get_preferred_aur_helper() {
        println!("üìã Current preferred helper: {}", current);
    }

    helper_options.push("‚¨ÖÔ∏è  Back".to_string());

    let choice = Select::with_theme(&ColorfulTheme::default())
        .with_prompt("Select preferred AUR helper")
        .items(&helper_options)
        .default(0)
        .interact()
        .unwrap();

    if choice < available_helpers.len() {
        let selected = available_helpers[choice];
        println!("‚úÖ Set {} as preferred AUR helper", selected);

        // Save preference to config file
        save_aur_helper_preference(selected);
    }
}

fn save_aur_helper_preference(helper: &str) {
    use std::fs;

    if let Some(config_dir) = dirs::config_dir() {
        let ghostctl_dir = config_dir.join("ghostctl");
        let _ = fs::create_dir_all(&ghostctl_dir);

        let config_file = ghostctl_dir.join("aur_helper");
        if let Err(e) = fs::write(config_file, helper) {
            println!("‚ö†Ô∏è  Warning: Could not save preference: {}", e);
        }
    }
}

pub fn get_preferred_aur_helper() -> Option<String> {
    use std::fs;

    // First check saved preference
    if let Some(config_dir) = dirs::config_dir() {
        let config_file = config_dir.join("ghostctl").join("aur_helper");
        if let Ok(saved_helper) = fs::read_to_string(config_file) {
            let saved_helper = saved_helper.trim();
            if Command::new("which").arg(saved_helper).status().is_ok() {
                return Some(saved_helper.to_string());
            }
        }
    }

    // Fallback to priority order: reap, paru, yay, others
    let helpers = ["reap", "paru", "yay", "trizen", "pikaur"];

    for helper in &helpers {
        if Command::new("which").arg(helper).status().is_ok() {
            return Some(helper.to_string());
        }
    }

    None
}

fn advanced_package_management() {
    println!("üîß Advanced Package Management");
    println!("==============================");

    let options = [
        "üì¶ Batch Install AUR Packages",
        "üîç Search AUR with Filters",
        "üìä Package Information & Dependencies",
        "üßπ Deep Clean Build Cache",
        "üîÑ Rebuild All AUR Packages",
        "üìã List Foreign/AUR Packages",
        "‚¨ÖÔ∏è  Back",
    ];

    let choice = Select::with_theme(&ColorfulTheme::default())
        .with_prompt("Advanced Package Management")
        .items(&options)
        .default(0)
        .interact()
        .unwrap();

    match choice {
        0 => batch_install_packages(),
        1 => search_aur_filtered(),
        2 => package_info_dependencies(),
        3 => deep_clean_cache(),
        4 => rebuild_all_aur(),
        5 => list_foreign_packages(),
        _ => return,
    }
}

fn batch_install_packages() {
    println!("üì¶ Batch Install AUR Packages");
    println!("=============================");

    let package_list: String = Input::new()
        .with_prompt("Enter package names (space-separated)")
        .interact_text()
        .unwrap();

    let packages: Vec<&str> = package_list.split_whitespace().collect();

    if packages.is_empty() {
        println!("‚ùå No packages specified");
        return;
    }

    println!("üìã Packages to install: {}", packages.join(", "));

    let confirm = Confirm::new()
        .with_prompt("Proceed with installation?")
        .default(true)
        .interact()
        .unwrap();

    if !confirm {
        return;
    }

    if let Some(helper) = get_preferred_aur_helper() {
        println!("üîÑ Installing packages with {}...", helper);

        for package in packages {
            println!("üì• Installing {}...", package);
            let status = Command::new(&helper)
                .args(["-S", "--noconfirm", package])
                .status();

            match status {
                Ok(s) if s.success() => println!("  ‚úÖ {} installed successfully", package),
                _ => println!("  ‚ùå Failed to install {}", package),
            }
        }
    } else {
        println!("‚ùå No AUR helper available");
    }
}

fn search_aur_filtered() {
    println!("üîç Search AUR with Filters");
    println!("==========================");

    let search_term: String = Input::new()
        .with_prompt("Search term")
        .interact_text()
        .unwrap();

    let filters = [
        "üìä Show package info",
        "üìã Show dependencies",
        "‚≠ê Sort by popularity",
        "üìÖ Sort by last modified",
    ];

    let selected_filters = MultiSelect::with_theme(&ColorfulTheme::default())
        .with_prompt("Select filters (Space to select, Enter to confirm)")
        .items(&filters)
        .interact()
        .unwrap();

    if let Some(helper) = get_preferred_aur_helper() {
        let mut args = vec!["-Ss"];
        args.push(&search_term);

        println!("üîç Searching for '{}'...", search_term);
        let _ = Command::new(helper).args(&args).status();

        if selected_filters.contains(&0) || selected_filters.contains(&1) {
            println!("\nüìä Getting detailed package information...");
            let _ = Command::new("pacman").args(["-Si", &search_term]).status();
        }
    } else {
        println!("‚ùå No AUR helper available");
    }
}

fn package_info_dependencies() {
    println!("üìä Package Information & Dependencies");
    println!("====================================");

    let package: String = Input::new()
        .with_prompt("Package name")
        .interact_text()
        .unwrap();

    println!("üìã Package Information for: {}", package);
    println!("-----------------------------------");

    // Check if package is installed
    let status = Command::new("pacman").args(["-Qi", &package]).status();

    if status.is_ok() && status.unwrap().success() {
        println!("‚úÖ Package is installed (showing local info)");
    } else {
        println!("üì¶ Package not installed (showing repository info)");
        let _ = Command::new("pacman").args(["-Si", &package]).status();
    }

    // Show dependency tree
    println!("\nüîó Dependency Tree:");
    let _ = Command::new("pactree").args([&package]).status();

    // Show reverse dependencies
    println!("\nüîÑ Reverse Dependencies (what depends on this):");
    let _ = Command::new("pactree").args(["-r", &package]).status();
}

fn deep_clean_cache() {
    println!("üßπ Deep Clean Build Cache");
    println!("=========================");

    let cache_locations = [
        "/tmp/yaourt-tmp-*",
        "/tmp/pamac-build-*",
        "/tmp/makepkg-*",
        "/tmp/yay-*",
        "/tmp/paru-*",
        "~/.cache/yay",
        "~/.cache/paru",
        "/var/cache/pacman/pkg/*",
    ];

    println!("üóÇÔ∏è  Cache locations to clean:");
    for location in &cache_locations {
        println!("  üìÅ {}", location);
    }

    let confirm = Confirm::new()
        .with_prompt("Clean all build caches?")
        .default(false)
        .interact()
        .unwrap();

    if confirm {
        println!("üßπ Cleaning build caches...");

        // Clean temp build directories
        let _ = Command::new("sudo")
            .args([
                "rm",
                "-rf",
                "/tmp/yaourt-tmp-*",
                "/tmp/pamac-build-*",
                "/tmp/makepkg-*",
                "/tmp/yay-*",
                "/tmp/paru-*",
            ])
            .status();

        // Clean user caches
        let _ = Command::new("rm")
            .args(["-rf", "~/.cache/yay", "~/.cache/paru"])
            .status();

        // Clean pacman cache (keep 3 most recent)
        let _ = Command::new("sudo")
            .args(["paccache", "-r", "-k3"])
            .status();

        println!("‚úÖ Build caches cleaned");
    }
}

fn rebuild_all_aur() {
    println!("üîÑ Rebuild All AUR Packages");
    println!("===========================");

    println!("üìã Finding AUR/foreign packages...");
    let output = Command::new("pacman").args(["-Qm"]).output();

    match output {
        Ok(output) if output.status.success() => {
            let foreign_packages = String::from_utf8_lossy(&output.stdout);
            let packages: Vec<&str> = foreign_packages
                .lines()
                .map(|line| line.split_whitespace().next().unwrap_or(""))
                .filter(|&pkg| !pkg.is_empty())
                .collect();

            if packages.is_empty() {
                println!("‚úÖ No foreign/AUR packages found");
                return;
            }

            println!("üì¶ Found {} AUR packages:", packages.len());
            for package in &packages {
                println!("  ‚Ä¢ {}", package);
            }

            let confirm = Confirm::new()
                .with_prompt("Rebuild all AUR packages?")
                .default(false)
                .interact()
                .unwrap();

            if confirm {
                if let Some(helper) = get_preferred_aur_helper() {
                    println!("üî® Rebuilding packages with {}...", helper);
                    let _ = Command::new(&helper)
                        .args(["-S", "--rebuild"])
                        .args(&packages)
                        .status();
                }
            }
        }
        _ => println!("‚ùå Failed to query foreign packages"),
    }
}

fn list_foreign_packages() {
    println!("üìã List Foreign/AUR Packages");
    println!("============================");

    println!("üîç Foreign packages (not in official repos):");
    let _ = Command::new("pacman").args(["-Qm"]).status();

    println!("\nüìä Package statistics:");
    let output = Command::new("pacman").args(["-Qm"]).output();

    if let Ok(output) = output {
        if output.status.success() {
            let count = String::from_utf8_lossy(&output.stdout).lines().count();
            println!("  Total foreign packages: {}", count);
        }
    }

    println!("\nüîç Explicitly installed packages:");
    let _ = Command::new("pacman").args(["-Qe"]).status();
}

fn diagnose_broken_packages() {
    println!("ü©∫ Diagnose & Fix Broken Packages");
    println!("=================================");

    let options = [
        "üîç Check for broken dependencies",
        "üîß Fix partial upgrades",
        "üì¶ Reinstall broken packages",
        "üóëÔ∏è  Remove orphaned dependencies",
        "üîÑ Fix database corruption",
        "üõ†Ô∏è  Repair package database",
        "‚¨ÖÔ∏è  Back",
    ];

    let choice = Select::with_theme(&ColorfulTheme::default())
        .with_prompt("Diagnostic Options")
        .items(&options)
        .default(0)
        .interact()
        .unwrap();

    match choice {
        0 => check_broken_dependencies(),
        1 => fix_partial_upgrades(),
        2 => reinstall_broken_packages(),
        3 => remove_orphaned_deps(),
        4 => fix_database_corruption(),
        5 => repair_package_database(),
        _ => return,
    }
}

fn check_broken_dependencies() {
    println!("üîç Checking for Broken Dependencies");
    println!("===================================");

    println!("üîÑ Running dependency check...");

    // Check for missing dependencies
    println!("\nüîó Checking for missing dependencies:");
    let status = Command::new("pacman").args(["-Dk"]).status();

    match status {
        Ok(s) if s.success() => println!("‚úÖ No missing dependencies found"),
        _ => {
            println!("‚ö†Ô∏è  Missing dependencies detected");

            let fix = Confirm::new()
                .with_prompt("Attempt to fix missing dependencies?")
                .default(true)
                .interact()
                .unwrap();

            if fix {
                println!("üîß Installing missing dependencies...");
                let _ = Command::new("sudo")
                    .args(["pacman", "-S", "--asdeps", "--needed"])
                    .status();
            }
        }
    }

    // Check for broken symlinks
    println!("\nüîó Checking for broken symlinks:");
    let _ = Command::new("find")
        .args(["/usr", "-xtype", "l", "-print"])
        .status();
}

fn fix_partial_upgrades() {
    println!("üîß Fix Partial Upgrades");
    println!("=======================");

    println!("‚ö†Ô∏è  Partial upgrades can cause system instability");

    let confirm = Confirm::new()
        .with_prompt("Force complete system upgrade?")
        .default(true)
        .interact()
        .unwrap();

    if confirm {
        println!("üîÑ Performing complete system upgrade...");
        let _ = Command::new("sudo")
            .args(["pacman", "-Syu", "--noconfirm"])
            .status();

        println!("‚úÖ System upgrade completed");
    }
}

fn reinstall_broken_packages() {
    println!("üì¶ Reinstall Broken Packages");
    println!("============================");

    let package_input: String = Input::new()
        .with_prompt("Enter package name (or 'auto' to detect broken packages)")
        .interact_text()
        .unwrap();

    if package_input == "auto" {
        println!("üîç Auto-detecting broken packages...");

        // Check for packages with missing files
        let output = Command::new("pacman").args(["-Qk"]).output();

        match output {
            Ok(output) if !output.status.success() => {
                println!("‚ö†Ô∏è  Found packages with missing files");

                let fix = Confirm::new()
                    .with_prompt("Reinstall packages with missing files?")
                    .default(true)
                    .interact()
                    .unwrap();

                if fix {
                    // Extract package names from pacman -Qk output and reinstall
                    let broken_output = String::from_utf8_lossy(&output.stderr);
                    println!("üîß Attempting to fix broken packages...");

                    // This would need more sophisticated parsing in a real implementation
                    let _ = Command::new("sudo")
                        .args(["pacman", "-S", "--noconfirm"])
                        .status();
                }
            }
            _ => println!("‚úÖ No broken packages detected"),
        }
    } else {
        println!("üîÑ Reinstalling {}...", package_input);
        let _ = Command::new("sudo")
            .args(["pacman", "-S", "--noconfirm", &package_input])
            .status();
    }
}

fn remove_orphaned_deps() {
    println!("üóëÔ∏è  Remove Orphaned Dependencies");
    println!("===============================");

    println!("üîç Finding orphaned packages...");
    let output = Command::new("pacman").args(["-Qtdq"]).output();

    match output {
        Ok(output) if output.status.success() => {
            let orphans = String::from_utf8_lossy(&output.stdout);
            let orphan_list: Vec<&str> = orphans.lines().collect();

            if orphan_list.is_empty() {
                println!("‚úÖ No orphaned packages found");
                return;
            }

            println!("üì¶ Found {} orphaned packages:", orphan_list.len());
            for orphan in &orphan_list {
                println!("  ‚Ä¢ {}", orphan);
            }

            let confirm = Confirm::new()
                .with_prompt("Remove all orphaned packages?")
                .default(true)
                .interact()
                .unwrap();

            if confirm {
                let status = Command::new("sudo")
                    .args(["pacman", "-Rns", "--noconfirm"])
                    .args(&orphan_list)
                    .status();

                match status {
                    Ok(s) if s.success() => println!("‚úÖ Orphaned packages removed"),
                    _ => println!("‚ùå Failed to remove some packages"),
                }
            }
        }
        _ => println!("‚úÖ No orphaned packages found"),
    }
}

fn fix_database_corruption() {
    println!("üîÑ Fix Database Corruption");
    println!("==========================");

    println!("‚ö†Ô∏è  This will rebuild the package database");

    let confirm = Confirm::new()
        .with_prompt("Proceed with database repair?")
        .default(false)
        .interact()
        .unwrap();

    if confirm {
        println!("üîß Removing pacman lock...");
        let _ = Command::new("sudo")
            .args(["rm", "-f", "/var/lib/pacman/db.lck"])
            .status();

        println!("üîÑ Synchronizing package databases...");
        let _ = Command::new("sudo").args(["pacman", "-Syy"]).status();

        println!("üîß Refreshing package databases...");
        let _ = Command::new("sudo").args(["pacman-db-upgrade"]).status();

        println!("‚úÖ Database repair completed");
    }
}

fn repair_package_database() {
    println!("üõ†Ô∏è  Repair Package Database");
    println!("==========================");

    let repair_options = [
        "üîÑ Refresh all package databases",
        "üîß Rebuild pacman database",
        "üóëÔ∏è  Clear package cache",
        "üîë Refresh GPG keys",
        "üåê Update mirror list",
    ];

    let selected = MultiSelect::with_theme(&ColorfulTheme::default())
        .with_prompt("Select repair operations")
        .items(&repair_options)
        .interact()
        .unwrap();

    if selected.is_empty() {
        return;
    }

    println!("üîß Performing selected repairs...");

    for &option in &selected {
        match option {
            0 => {
                println!("üîÑ Refreshing package databases...");
                let _ = Command::new("sudo").args(["pacman", "-Syy"]).status();
            }
            1 => {
                println!("üîß Rebuilding pacman database...");
                let _ = Command::new("sudo").args(["pacman-db-upgrade"]).status();
            }
            2 => {
                println!("üóëÔ∏è  Clearing package cache...");
                let _ = Command::new("sudo")
                    .args(["pacman", "-Scc", "--noconfirm"])
                    .status();
            }
            3 => {
                println!("üîë Refreshing GPG keys...");
                crate::arch::fix_gpg_keys();
            }
            4 => {
                println!("üåê Updating mirror list...");
                crate::arch::optimize_mirrors();
            }
            _ => {}
        }
    }

    println!("‚úÖ Database repair operations completed");
}

fn dependency_resolution_tools() {
    println!("üîó Dependency Resolution Tools");
    println!("==============================");

    let options = [
        "üîç Analyze dependency tree",
        "üîÑ Find circular dependencies",
        "üì¶ Check missing dependencies",
        "‚ö° Optimize dependency cache",
        "üßπ Clean dependency cache",
        "‚¨ÖÔ∏è  Back",
    ];

    let choice = Select::with_theme(&ColorfulTheme::default())
        .with_prompt("Dependency Tools")
        .items(&options)
        .default(0)
        .interact()
        .unwrap();

    match choice {
        0 => analyze_dependency_tree(),
        1 => find_circular_dependencies(),
        2 => check_missing_dependencies(),
        3 => optimize_dependency_cache(),
        4 => clean_dependency_cache(),
        _ => return,
    }
}

fn analyze_dependency_tree() {
    println!("üîç Analyze Dependency Tree");
    println!("==========================");

    let package: String = Input::new()
        .with_prompt("Package name to analyze")
        .interact_text()
        .unwrap();

    println!("üå≥ Dependency tree for: {}", package);
    println!("----------------------------");

    // Show full dependency tree
    let _ = Command::new("pactree")
        .args(["-c", "-d", "3", &package])
        .status();

    // Show size information
    println!("\nüìä Package size information:");
    let _ = Command::new("pacman").args(["-Qi", &package]).status();
}

fn find_circular_dependencies() {
    println!("üîÑ Find Circular Dependencies");
    println!("=============================");

    println!("üîç Scanning for circular dependencies...");

    // This is a simplified check - real implementation would be more complex
    let output = Command::new("pacman").args(["-Q"]).output();

    match output {
        Ok(output) if output.status.success() => {
            let packages = String::from_utf8_lossy(&output.stdout);
            let package_count = packages.lines().count();

            println!("üìä Checked {} packages", package_count);
            println!(
                "üí° For detailed circular dependency detection, consider using specialized tools"
            );

            // Basic check using pactree
            println!("üîç Running basic circular dependency check...");
            let _ = Command::new("sh")
                .arg("-c")
                .arg("for pkg in $(pacman -Qq | head -10); do echo \"Checking $pkg:\"; pactree -r \"$pkg\" 2>/dev/null | head -5; done")
                .status();
        }
        _ => println!("‚ùå Failed to query packages"),
    }
}

fn check_missing_dependencies() {
    println!("üì¶ Check Missing Dependencies");
    println!("=============================");

    println!("üîç Checking for missing dependencies...");

    let status = Command::new("pacman").args(["-Dk"]).status();

    match status {
        Ok(s) if s.success() => {
            println!("‚úÖ All dependencies satisfied");
        }
        _ => {
            println!("‚ö†Ô∏è  Missing dependencies found");

            println!("\nüîß Checking specific package dependencies:");
            let package: String = Input::new()
                .with_prompt("Enter package name to check (or press Enter to skip)")
                .allow_empty(true)
                .interact_text()
                .unwrap();

            if !package.is_empty() {
                let _ = Command::new("pacman").args(["-Dk", &package]).status();
            }
        }
    }
}

fn optimize_dependency_cache() {
    println!("‚ö° Optimize Dependency Cache");
    println!("===========================");

    println!("üîç Analyzing package cache...");

    // Show cache statistics
    let output = Command::new("du")
        .args(["-sh", "/var/cache/pacman/pkg/"])
        .output();

    if let Ok(output) = output {
        if output.status.success() {
            let size = String::from_utf8_lossy(&output.stdout);
            println!("üìä Current cache size: {}", size.trim());
        }
    }

    let optimize_options = [
        "üóëÔ∏è  Remove all cached packages except installed versions",
        "üì¶ Keep only 3 most recent versions",
        "üßπ Remove only uninstalled packages",
        "üìä Show cache statistics only",
    ];

    let choice = Select::with_theme(&ColorfulTheme::default())
        .with_prompt("Optimization method")
        .items(&optimize_options)
        .default(1)
        .interact()
        .unwrap();

    match choice {
        0 => {
            let _ = Command::new("sudo")
                .args(["paccache", "-r", "-k0"])
                .status();
        }
        1 => {
            let _ = Command::new("sudo")
                .args(["paccache", "-r", "-k3"])
                .status();
        }
        2 => {
            let _ = Command::new("sudo").args(["paccache", "-r", "-u"]).status();
        }
        3 => {
            let _ = Command::new("paccache").args(["-d"]).status();
        }
        _ => return,
    }

    println!("‚úÖ Cache optimization completed");
}

fn clean_dependency_cache() {
    println!("üßπ Clean Dependency Cache");
    println!("=========================");

    let cache_options = [
        "üóëÔ∏è  Clean pacman cache",
        "üßπ Clean AUR build cache",
        "üìÅ Clean temporary build files",
        "üîÑ Clean all caches",
    ];

    let selected = MultiSelect::with_theme(&ColorfulTheme::default())
        .with_prompt("Select caches to clean")
        .items(&cache_options)
        .interact()
        .unwrap();

    if selected.is_empty() {
        return;
    }

    for &option in &selected {
        match option {
            0 => {
                println!("üóëÔ∏è  Cleaning pacman cache...");
                let _ = Command::new("sudo")
                    .args(["pacman", "-Sc", "--noconfirm"])
                    .status();
            }
            1 => {
                println!("üßπ Cleaning AUR build cache...");
                let _ = Command::new("rm")
                    .args(["-rf", "~/.cache/yay", "~/.cache/paru"])
                    .status();
            }
            2 => {
                println!("üìÅ Cleaning temporary build files...");
                let _ = Command::new("sudo")
                    .args(["rm", "-rf", "/tmp/makepkg-*", "/tmp/yay-*", "/tmp/paru-*"])
                    .status();
            }
            3 => {
                println!("üîÑ Cleaning all caches...");
                let _ = Command::new("sudo")
                    .args(["pacman", "-Scc", "--noconfirm"])
                    .status();
                let _ = Command::new("rm")
                    .args(["-rf", "~/.cache/yay", "~/.cache/paru"])
                    .status();
                let _ = Command::new("sudo")
                    .args(["rm", "-rf", "/tmp/makepkg-*", "/tmp/yay-*", "/tmp/paru-*"])
                    .status();
            }
            _ => {}
        }
    }

    println!("‚úÖ Cache cleaning completed");
}

fn package_conflict_resolution() {
    println!("üìã Package Conflict Resolution");
    println!("==============================");

    let options = [
        "üîç Detect package conflicts",
        "üîß Resolve file conflicts",
        "üì¶ Fix broken packages",
        "üîÑ Force reinstall conflicting packages",
        "üóëÔ∏è  Remove conflicting packages",
        "‚¨ÖÔ∏è  Back",
    ];

    let choice = Select::with_theme(&ColorfulTheme::default())
        .with_prompt("Conflict Resolution")
        .items(&options)
        .default(0)
        .interact()
        .unwrap();

    match choice {
        0 => detect_package_conflicts(),
        1 => resolve_file_conflicts(),
        2 => fix_broken_packages_conflicts(),
        3 => force_reinstall_conflicts(),
        4 => remove_conflicting_packages(),
        _ => return,
    }
}

fn detect_package_conflicts() {
    println!("üîç Detect Package Conflicts");
    println!("===========================");

    println!("üîÑ Scanning for package conflicts...");

    // Check for file conflicts
    println!("üìÅ Checking for file conflicts:");
    let _ = Command::new("pacman").args(["-Qkk"]).status();

    // Check for dependency conflicts
    println!("\nüîó Checking dependency conflicts:");
    let _ = Command::new("pacman").args(["-Dk"]).status();

    println!("\nüì¶ Checking for broken packages:");
    let output = Command::new("pacman").args(["-Qk"]).output();

    match output {
        Ok(output) if !output.status.success() => {
            println!("‚ö†Ô∏è  Found broken packages - check output above");
        }
        _ => println!("‚úÖ No obvious package conflicts detected"),
    }
}

fn resolve_file_conflicts() {
    println!("üîß Resolve File Conflicts");
    println!("=========================");

    let conflict_file: String = Input::new()
        .with_prompt("Enter conflicting file path (or package name)")
        .interact_text()
        .unwrap();

    println!("üîç Analyzing conflicts for: {}", conflict_file);

    // Show which packages own the file
    let _ = Command::new("pacman")
        .args(["-Qo", &conflict_file])
        .status();

    // Show file information
    let _ = Command::new("ls").args(["-la", &conflict_file]).status();

    let resolution_options = [
        "üîÑ Reinstall owning package",
        "üóëÔ∏è  Remove conflicting file",
        "üìÅ Backup and replace file",
        "‚è≠Ô∏è  Skip resolution",
    ];

    let choice = Select::with_theme(&ColorfulTheme::default())
        .with_prompt("Resolution method")
        .items(&resolution_options)
        .default(0)
        .interact()
        .unwrap();

    match choice {
        0 => {
            // Try to find and reinstall the package that owns this file
            let output = Command::new("pacman")
                .args(["-Qo", &conflict_file])
                .output();

            if let Ok(output) = output {
                if output.status.success() {
                    let owner_info = String::from_utf8_lossy(&output.stdout);
                    if let Some(package) = owner_info.split_whitespace().nth(4) {
                        println!("üîÑ Reinstalling {}...", package);
                        let _ = Command::new("sudo")
                            .args(["pacman", "-S", "--noconfirm", package])
                            .status();
                    }
                }
            }
        }
        1 => {
            let confirm = Confirm::new()
                .with_prompt("Are you sure you want to remove this file?")
                .default(false)
                .interact()
                .unwrap();

            if confirm {
                let _ = Command::new("sudo")
                    .args(["rm", "-f", &conflict_file])
                    .status();
            }
        }
        2 => {
            println!("üìÅ Creating backup...");
            let backup_name = format!("{}.backup", conflict_file);
            let _ = Command::new("sudo")
                .args(["cp", &conflict_file, &backup_name])
                .status();
            println!("‚úÖ Backup created: {}", backup_name);
        }
        _ => return,
    }
}

fn fix_broken_packages_conflicts() {
    println!("üì¶ Fix Broken Packages");
    println!("======================");

    println!("üîÑ Running comprehensive package check...");

    // Full package verification
    let status = Command::new("pacman").args(["-Qkk"]).status();

    if status.is_ok() && !status.unwrap().success() {
        println!("‚ö†Ô∏è  Found broken packages");

        let fix_options = [
            "üîÑ Reinstall all broken packages",
            "üßπ Remove and reinstall",
            "üîß Attempt automatic fix",
            "‚è≠Ô∏è  Manual review only",
        ];

        let choice = Select::with_theme(&ColorfulTheme::default())
            .with_prompt("Fix method")
            .items(&fix_options)
            .default(2)
            .interact()
            .unwrap();

        match choice {
            0 | 1 => {
                println!("üîÑ This would attempt to fix broken packages...");
                println!("üí° Run 'sudo pacman -S $(pacman -Qkk 2>&1 | grep 'warning' | awk '{{print $2}}' | sort -u)' manually");
            }
            2 => {
                println!("üîß Attempting automatic fix...");
                let _ = Command::new("sudo")
                    .args([
                        "pacman",
                        "-S",
                        "--noconfirm",
                        "$(pacman -Qkk 2>&1 | grep warning | awk '{print $2}' | sort -u)",
                    ])
                    .status();
            }
            _ => {}
        }
    } else {
        println!("‚úÖ No broken packages found");
    }
}

fn force_reinstall_conflicts() {
    println!("üîÑ Force Reinstall Conflicting Packages");
    println!("=======================================");

    let package: String = Input::new()
        .with_prompt("Package name to force reinstall")
        .interact_text()
        .unwrap();

    println!("‚ö†Ô∏è  Force reinstalling: {}", package);

    let confirm = Confirm::new()
        .with_prompt("This will overwrite files. Continue?")
        .default(false)
        .interact()
        .unwrap();

    if confirm {
        let _ = Command::new("sudo")
            .args(["pacman", "-S", "--overwrite", "*", "--noconfirm", &package])
            .status();

        println!("‚úÖ Force reinstall completed");
    }
}

fn remove_conflicting_packages() {
    println!("üóëÔ∏è  Remove Conflicting Packages");
    println!("==============================");

    let packages: String = Input::new()
        .with_prompt("Enter package names to remove (space-separated)")
        .interact_text()
        .unwrap();

    let package_list: Vec<&str> = packages.split_whitespace().collect();

    if package_list.is_empty() {
        println!("‚ùå No packages specified");
        return;
    }

    println!("üóëÔ∏è  Packages to remove: {}", package_list.join(", "));

    let confirm = Confirm::new()
        .with_prompt("Remove these packages and their dependencies?")
        .default(false)
        .interact()
        .unwrap();

    if confirm {
        let _ = Command::new("sudo")
            .args(["pacman", "-Rns", "--noconfirm"])
            .args(&package_list)
            .status();

        println!("‚úÖ Package removal completed");
    }
}
